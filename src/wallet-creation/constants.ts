/**
 * ZERA Wallet Creation Constants
 * 
 * ⚠️  CRITICAL SECURITY NOTICE: BIP44 INCOMPATIBILITY  ⚠️
 * 
 * This implementation uses SLIP-0010 hardened derivation paths, which are
 * FUNDAMENTALLY INCOMPATIBLE with standard BIP44 wallets.
 * 
 * WHY THIS INCOMPATIBILITY EXISTS:
 * - EdDSA curves (Ed25519/Ed448) CANNOT perform public key derivation
 * - Mixed hardened/normal derivation creates security vulnerabilities
 * - Full hardening is a cryptographic requirement, not a design choice
 * 
 * BIP44 PATH:     m/44/1110/0/0/0 (mixed hardened/normal)
 * OUR PATH:       m/44'/1110'/0'/0'/0' (all hardened)
 * 
 * IMPACT: Addresses generated by BIP44 wallets cannot be reproduced by our
 * system and vice versa. This is a necessary security trade-off.
 * 
 * STANDARDS: We follow SLIP-0010 (de-facto standard for EdDSA HD wallets)
 */

import type { KeyType, HashType, MnemonicLength } from '../types/index.js';

// ZERA Network constants
export const ZERA_TYPE = 1110; // SLIP44 coin type for ZRA
export const ZERA_TYPE_HEX = '0x80000456';
export const ZERA_SYMBOL = 'ZRA';
export const ZERA_NAME = 'ZERA';

// SLIP-0010 derivation path for Ed25519/Ed448 (fully hardened)
// ⚠️  WARNING: This is NOT BIP44 compatible due to EdDSA security requirements
// While the path structure follows BIP44 format, it enforces SLIP-0010 hardening
// which prevents interoperability with standard BIP44 wallets
export const SLIP0010_DERIVATION_PATH = `m/44'/${ZERA_TYPE}'/0'/0'/0'`;

// Legacy name for backward compatibility (deprecated - use SLIP0010_DERIVATION_PATH)
export const DERIVATION_PATH = SLIP0010_DERIVATION_PATH;

// Only valid derivation scheme for Ed25519/Ed448
export const DERIVATION_SCHEME = 'slip0010'; // SLIP-0010 (fully hardened for Ed25519/Ed448)

// Key type enums - these are the only valid key types
export const KEY_TYPE = {
  ED25519: 'ed25519',
  ED448: 'ed448'
} as const;

// Hash type enums - these are the only valid hash types
export const HASH_TYPE = {
  SHA3_256: 'sha3-256',
  SHA3_512: 'sha3-512',
  BLAKE3: 'blake3'
} as const;

// Key type prefixes for display
export const KEY_TYPE_PREFIXES: Record<KeyType, string> = {
  [KEY_TYPE.ED25519]: 'A_',
  [KEY_TYPE.ED448]: 'B_'
};

// Hash type prefixes for display
export const HASH_TYPE_PREFIXES: Record<HashType, string> = {
  [HASH_TYPE.SHA3_256]: 'a_',
  [HASH_TYPE.SHA3_512]: 'b_',
  [HASH_TYPE.BLAKE3]: 'c_'
};

// Type arrays for validation
export const VALID_KEY_TYPES: readonly KeyType[] = Object.values(KEY_TYPE);
export const VALID_HASH_TYPES: readonly HashType[] = Object.values(HASH_TYPE);

// Legacy support - keep existing constants
export const SUPPORTED_KEY_TYPES = VALID_KEY_TYPES;
export const KEY_TYPES = KEY_TYPE_PREFIXES; // For backward compatibility

// ZERA extended key version bytes (custom to prevent cross-chain confusion)
export const EXTENDED_KEY_VERSIONS = {
  PRIVATE: 0x04b2430c, // ZERA private key version
  PUBLIC: 0x04b2430d   // ZERA public key version
} as const;

// BIP39 supported mnemonic lengths
export const MNEMONIC_LENGTHS: readonly MnemonicLength[] = [12, 15, 18, 21, 24];

// Default HD wallet settings
export const DEFAULT_HD_SETTINGS = {
  accountIndex: 0,
  changeIndex: 0,
  addressIndex: 0
} as const;

// Error messages
export const ERROR_MESSAGES = {
  INVALID_KEY_TYPE: `Invalid key type. Must be one of: ${VALID_KEY_TYPES.join(', ')}`,
  INVALID_HASH_TYPE: `Invalid hash type. Must be one of: ${VALID_HASH_TYPES.join(', ')}`,
  INVALID_MNEMONIC_LENGTH: `Invalid mnemonic length. Must be one of: ${MNEMONIC_LENGTHS.join(', ')}`,
  INVALID_MNEMONIC: 'Invalid BIP39 mnemonic phrase',
  INVALID_DERIVATION_PATH: 'Invalid derivation path format',
  INVALID_ACCOUNT_INDEX: 'Account index must be a non-negative integer',
  INVALID_CHANGE_INDEX: 'Change index must be 0 or 1',
  INVALID_ADDRESS_INDEX: 'Address index must be a non-negative integer',
  MNEMONIC_REQUIRED: 'Mnemonic phrase is required',
  KEY_TYPE_REQUIRED: 'Key type is required',
  HASH_TYPES_REQUIRED: 'Hash types array is required'
} as const;

// Type guards and validation functions
export function isValidKeyType(keyType: any): keyType is KeyType {
  return VALID_KEY_TYPES.includes(keyType as KeyType);
}

export function isValidHashType(hashType: any): hashType is HashType {
  return VALID_HASH_TYPES.includes(hashType as HashType);
}

export function isValidMnemonicLength(length: any): length is MnemonicLength {
  return MNEMONIC_LENGTHS.includes(length as MnemonicLength);
}

export function validateSLIP0010Path(path: any): path is string {
  if (!path || typeof path !== 'string') return false;
  if (!path.startsWith('m/')) return false;
  
  const parts = path.split('/');
  if (parts.length !== 6) return false;
  
  try {
    // All components must be hardened
    for (let i = 1; i < parts.length; i++) {
      if (!parts[i]?.endsWith("'")) return false;
    }
    
    // Purpose must be 44
    if (parseInt(parts[1]?.slice(0, -1) || '0') !== 44) return false;
    
    // Coin type must be ZERA (1110)
    if (parseInt(parts[2]?.slice(0, -1) || '0') !== ZERA_TYPE) return false;
    
    return true;
  } catch (error) {
    return false;
  }
}

// Get key type prefix
export function getKeyTypePrefix(keyType: KeyType): string {
  return KEY_TYPE_PREFIXES[keyType];
}

// Get hash type prefix
export function getHashTypePrefix(hashType: HashType): string {
  return HASH_TYPE_PREFIXES[hashType];
}
